
==================== FINAL INTERFACE ====================
2017-01-08 01:33:08.094869945 UTC

interface xmonadrc-0.0.1.0-E6HMStyFiyjAVPFmc9oFTv:XMonad.Util.Lemonbar 8001
  interface hash: 331685eb202a49a6ee8d3d5b33989e69
  ABI hash: 86a711d8d57322cd39da4fc170316b66
  export-list hash: 301ff19b5186ae53867daa46237f5719
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: e3576b0c2db657f284ecc6f7434d6429
  sig of: Nothing
  used TH splices: False
  where
exports:
  XMonad.Util.Lemonbar.lbAlignCenter
  XMonad.Util.Lemonbar.lbAlignLeft
  XMonad.Util.Lemonbar.lbAlignRight
  XMonad.Util.Lemonbar.lbClick
  XMonad.Util.Lemonbar.lbClickL
  XMonad.Util.Lemonbar.lbColor
  XMonad.Util.Lemonbar.lbColorL
  XMonad.Util.Lemonbar.lbFontIdx
  XMonad.Util.Lemonbar.lbFontIdxL
  XMonad.Util.Lemonbar.lbLineColor
  XMonad.Util.Lemonbar.lbLineColorL
  XMonad.Util.Lemonbar.lbOverline
  XMonad.Util.Lemonbar.lbOverlineL
  XMonad.Util.Lemonbar.lbReverse
  XMonad.Util.Lemonbar.lbReverseL
  XMonad.Util.Lemonbar.lbUnderline
  XMonad.Util.Lemonbar.lbUnderlineL
module dependencies:
package dependencies: X11-1.7@X11-1.7-5RhPpcHRMKqDNH6DKI6wnL
                      X11-xft-0.3.1@X11-xft-0.3.1-K5aCxhr7PdkBJ0izTORldG
                      array-0.5.1.1@array-0.5.1.1 base-4.9.0.0
                      containers-0.5.7.1@containers-0.5.7.1
                      data-default-0.7.1.1@data-default-0.7.1.1-5uix4eIzBY9IcVb4V2HbW3
                      data-default-class-0.1.2.0@data-default-class-0.1.2.0-FYQpjIylblBDctdkHAFeXA
                      data-default-instances-containers-0.0.1@data-default-instances-containers-0.0.1-B3LqdWnlDzL8N7WtQnkQ3T
                      data-default-instances-dlist-0.0.1@data-default-instances-dlist-0.0.1-7EnnOuRxBMR4O5lm1rpRqD
                      data-default-instances-old-locale-0.0.1@data-default-instances-old-locale-0.0.1-LPOHPEJCJUa53W1ZYaHB84
                      deepseq-1.4.2.0@deepseq-1.4.2.0 directory-1.2.6.2@directory-1.2.6.2
                      dlist-0.8.0.2@dlist-0.8.0.2-GWAMmbX9rLg3tqrbOizHGv
                      extensible-exceptions-0.1.1.4@extensible-exceptions-0.1.1.4-3h0ykvvAO915cRhUyj3rRV
                      filepath-1.4.1.0@filepath-1.4.1.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM
                      old-locale-1.0.0.7@old-locale-1.0.0.7-6glXNhHF891B41ZfuI8hU8
                      old-time-1.1.0.3@old-time-1.1.0.3-IcvdkJUsE9M8t3io8peAEp
                      process-1.4.2.0@process-1.4.2.0
                      setlocale-1.0.0.4@setlocale-1.0.0.4-EUtO5CfNQTBH7QTFQEDDaI
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
                      unix-2.7.2.0@unix-2.7.2.0
                      utf8-string-1.0.1.1@utf8-string-1.0.1.1-2T8mBCuEDlXDo8zed8Onw4
                      xmonad-0.12@xmonad-0.12-C7fwoSClEurF1iRX9ijBYI
                      xmonad-contrib-0.12@xmonad-contrib-0.12-5yojTYrxlmNEezmwtDgaRd
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         data-default-instances-containers-0.0.1@data-default-instances-containers-0.0.1-B3LqdWnlDzL8N7WtQnkQ3T:Data.Default.Instances.Containers
         data-default-instances-dlist-0.0.1@data-default-instances-dlist-0.0.1-7EnnOuRxBMR4O5lm1rpRqD:Data.Default.Instances.DList
         data-default-instances-old-locale-0.0.1@data-default-instances-old-locale-0.0.1-LPOHPEJCJUa53W1ZYaHB84:Data.Default.Instances.OldLocale
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         xmonad-0.12@xmonad-0.12-C7fwoSClEurF1iRX9ijBYI:XMonad.Config
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         dlist-0.8.0.2@dlist-0.8.0.2-GWAMmbX9rLg3tqrbOizHGv:Data.DList
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  xmonad-contrib-0.12@xmonad-contrib-0.12-5yojTYrxlmNEezmwtDgaRd:XMonad.Hooks.DynamicLog 1dd559bcd58af255db05718545088b65
import  -/  xmonad-contrib-0.12@xmonad-contrib-0.12-5yojTYrxlmNEezmwtDgaRd:XMonad.Util.Loggers eeeff42630d9898e4f8bf47e70894bfa
72ab73f4d148f726046c9277c40809e0
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   XMonad.Util.Lemonbar.$trModule2
                   XMonad.Util.Lemonbar.$trModule1) -}
dc1f615fa49c627c15c5685d67fec83e
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "XMonad.Util.Lemonbar"#) -}
2ee2fc7e2baefacff2dab1d4977bf89d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "xmonadrc-0.0.1.0-E6HMStyFiyjAVPFmc9oFTv"#) -}
7e0c452afe6c62d05a53912ef832dbd4
  lbAlignCenter :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "%{c}"#) -}
36908db2e828129116d44084542c128d
  lbAlignLeft :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "%{l}"#) -}
97268947a788dd6561eea94002e591c8
  lbAlignRight :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "%{r}"#) -}
3130b470e5b2a0e12696fc3d16addb79
  lbClick ::
    GHC.Types.Int
    -> GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(U)><L,1*U>,
     Unfolding: (\ (button :: GHC.Types.Int)
                   (action :: GHC.Base.String) ->
                 let {
                   ds :: GHC.Base.String
                   = GHC.CString.unpackAppendCString#
                       "%{A"#
                       (case button of ww2 { GHC.Types.I# ww3 ->
                        case GHC.Show.$wshowSignedInt
                               0#
                               ww3
                               (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                        GHC.Base.++
                          @ GHC.Types.Char
                          (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                          (GHC.CString.unpackAppendCString#
                             ":"#
                             (GHC.Base.++
                                @ GHC.Types.Char
                                action
                                XMonad.Util.Lemonbar.lbClick2)) } })
                 } in
                 \ (ds2 :: [GHC.Types.Char]) ->
                 case ds2 of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : ipv ipv1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ds
                        (GHC.Base.++
                           @ GHC.Types.Char
                           wild
                           XMonad.Util.Lemonbar.lbClick1) }) -}
1372e6d329f9f04e4494e388caad48a3
  lbClick1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{A}"#) -}
fd979cee5cc63dcc221c7159169a4a72
  lbClick2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ":}"#) -}
dd0ca1a9a93888acade06ce46544435a
  lbClickL ::
    GHC.Types.Int
    -> GHC.Base.String
    -> XMonad.Util.Loggers.Logger
    -> XMonad.Util.Loggers.Logger
  {- Arity: 2, Strictness: <L,1*U(U)><L,1*U>,
     Unfolding: InlineRule (0, True, True)
                XMonad.Util.Lemonbar.lbClickL1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N
                 ->_R Trans
                          (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                    <*>_N
                                    <XMonad.Core.XConf>_R
                                    <Control.Monad.Trans.State.Lazy.StateT
                                       XMonad.Core.XState GHC.Types.IO>_R
                                    <GHC.Base.Maybe GHC.Base.String>_N))
                          (Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N)) -}
e6fe956ea837afa921abe6f265261713
  lbClickL1 ::
    GHC.Types.Int
    -> GHC.Base.String
    -> Control.Monad.Trans.Reader.ReaderT
         XMonad.Core.XConf
         (Control.Monad.Trans.State.Lazy.StateT
            XMonad.Core.XState GHC.Types.IO)
         (GHC.Base.Maybe GHC.Base.String)
    -> XMonad.Core.XConf
    -> Control.Monad.Trans.State.Lazy.StateT
         XMonad.Core.XState GHC.Types.IO (GHC.Base.Maybe GHC.Base.String)
  {- Arity: 2, Strictness: <L,1*U(U)><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (b :: GHC.Types.Int) (a :: GHC.Base.String) ->
                 XMonad.Util.Loggers.dzenColorL2
                   (XMonad.Util.Lemonbar.lbClick b a)) -}
465cc10b8e41145c5a563ced8fe0cf83
  lbColor ::
    GHC.Base.String
    -> GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ (fg :: GHC.Base.String) (bg :: GHC.Base.String) ->
                 let {
                   ds :: GHC.Base.String
                   = let {
                       arg :: [GHC.Types.Char]
                       = case bg of wild {
                           [] -> GHC.Types.[] @ GHC.Types.Char
                           : ds1 ds2
                           -> GHC.Base.++
                                @ GHC.Types.Char
                                XMonad.Util.Lemonbar.lbColor5
                                (GHC.Base.++ @ GHC.Types.Char wild XMonad.Util.Lemonbar.lbColor4) }
                     } in
                     case fg of wild {
                       [] -> arg
                       : ds1 ds2
                       -> GHC.Base.++
                            @ GHC.Types.Char
                            XMonad.Util.Lemonbar.lbColor3
                            (GHC.Base.++
                               @ GHC.Types.Char
                               wild
                               (GHC.Base.++ @ GHC.Types.Char XMonad.Util.Lemonbar.lbColor4 arg)) }
                 } in
                 let {
                   ds1 :: GHC.Base.String
                   = case fg of wild {
                       []
                       -> case bg of wild1 {
                            [] -> GHC.Types.[] @ GHC.Types.Char
                            : ds2 ds3 -> XMonad.Util.Lemonbar.lbColor2 }
                       : ds2 ds3
                       -> GHC.Base.++
                            @ GHC.Types.Char
                            XMonad.Util.Lemonbar.lbColor1
                            (case bg of wild1 {
                               [] -> GHC.Types.[] @ GHC.Types.Char
                               : ds4 ds5 -> XMonad.Util.Lemonbar.lbColor2 }) }
                 } in
                 \ (ds2 :: [GHC.Types.Char]) ->
                 case ds2 of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : ipv ipv1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ds
                        (GHC.Base.++ @ GHC.Types.Char wild ds1) }) -}
add69c0794f0e8702d355afa5da28e68
  lbColor1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{F-}"#) -}
638b83d43b1cfb0a085917980ebfdbba
  lbColor2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{B-}"#) -}
c0fd8e40ec7d39fdfc27e45e82ecd038
  lbColor3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{F"#) -}
fed595975c6c0f49edd9b3ed1445d913
  lbColor4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
30c10d2ea807659dab6f1095148d8ef1
  lbColor5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{B"#) -}
6c41ff6a50a306113550be964d1d5cc8
  lbColorL ::
    GHC.Base.String
    -> GHC.Base.String
    -> XMonad.Util.Loggers.Logger
    -> XMonad.Util.Loggers.Logger
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                XMonad.Util.Lemonbar.lbColorL1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N
                 ->_R Trans
                          (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                    <*>_N
                                    <XMonad.Core.XConf>_R
                                    <Control.Monad.Trans.State.Lazy.StateT
                                       XMonad.Core.XState GHC.Types.IO>_R
                                    <GHC.Base.Maybe GHC.Base.String>_N))
                          (Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N)) -}
9d7de00fa5392da4ecc92155afa09b50
  lbColorL1 ::
    GHC.Base.String
    -> GHC.Base.String
    -> Control.Monad.Trans.Reader.ReaderT
         XMonad.Core.XConf
         (Control.Monad.Trans.State.Lazy.StateT
            XMonad.Core.XState GHC.Types.IO)
         (GHC.Base.Maybe GHC.Base.String)
    -> XMonad.Core.XConf
    -> Control.Monad.Trans.State.Lazy.StateT
         XMonad.Core.XState GHC.Types.IO (GHC.Base.Maybe GHC.Base.String)
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (fg :: GHC.Base.String) (bg :: GHC.Base.String) ->
                 XMonad.Util.Loggers.dzenColorL2
                   (XMonad.Util.Lemonbar.lbColor fg bg)) -}
d9330d29250735d1f5643db0cdc89c18
  lbFontIdx :: GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(U)><L,1*U>,
     Unfolding: (\ (n :: GHC.Types.Int) (s :: GHC.Base.String) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   XMonad.Util.Lemonbar.lbFontIdx2
                   (case n of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           0#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                      (GHC.Base.++
                         @ GHC.Types.Char
                         XMonad.Util.Lemonbar.lbColor4
                         (GHC.Base.++
                            @ GHC.Types.Char
                            s
                            XMonad.Util.Lemonbar.lbFontIdx1)) } })) -}
22f2053f581f39002ca5280a7cf5f46d
  lbFontIdx1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{T-}"#) -}
f8a446268c43d432318af77e8998110c
  lbFontIdx2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{T"#) -}
442fceeffc1369d9f7ffac73d05efd02
  lbFontIdxL ::
    GHC.Types.Int
    -> XMonad.Util.Loggers.Logger -> XMonad.Util.Loggers.Logger
  {- Arity: 3, Strictness: <L,U(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                XMonad.Util.Lemonbar.lbFontIdxL1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N
                 ->_R Trans
                          (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                    <*>_N
                                    <XMonad.Core.XConf>_R
                                    <Control.Monad.Trans.State.Lazy.StateT
                                       XMonad.Core.XState GHC.Types.IO>_R
                                    <GHC.Base.Maybe GHC.Base.String>_N))
                          (Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N)) -}
1c77190013464a3966eb18208fd56e3d
  lbFontIdxL1 ::
    GHC.Types.Int
    -> Control.Monad.Trans.Reader.ReaderT
         XMonad.Core.XConf
         (Control.Monad.Trans.State.Lazy.StateT
            XMonad.Core.XState GHC.Types.IO)
         (GHC.Base.Maybe GHC.Base.String)
    -> XMonad.Core.XConf
    -> Control.Monad.Trans.State.Lazy.StateT
         XMonad.Core.XState GHC.Types.IO (GHC.Base.Maybe GHC.Base.String)
  {- Arity: 3, Strictness: <L,U(U)><L,1*C1(U)><L,U>,
     Unfolding: (\ (fn :: GHC.Types.Int)
                   (eta1 :: Control.Monad.Trans.Reader.ReaderT
                              XMonad.Core.XConf
                              (Control.Monad.Trans.State.Lazy.StateT
                                 XMonad.Core.XState GHC.Types.IO)
                              (GHC.Base.Maybe GHC.Base.String))
                   (eta2 :: XMonad.Core.XConf) ->
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           XMonad.Core.XState GHC.Types.IO (GHC.Base.Maybe GHC.Base.String)
                   = eta1
                       `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <XMonad.Core.XConf>_R
                          <Control.Monad.Trans.State.Lazy.StateT
                             XMonad.Core.XState GHC.Types.IO>_R
                          <GHC.Base.Maybe GHC.Base.String>_N)
                       eta2
                 } in
                 (\ (s1 :: XMonad.Core.XState)
                    (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <XMonad.Core.XState>_N
                             <GHC.Types.IO>_R
                             <GHC.Base.Maybe GHC.Base.String>_N)
                          s1)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <(GHC.Base.Maybe GHC.Base.String, XMonad.Core.XState)>_R)
                         eta of ds { (#,#) ipv ipv1 ->
                  (# ipv,
                     (case ipv1 of wild { (,) a1 s' ->
                      case a1 of wild1 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Base.String
                        GHC.Base.Just x1
                        -> GHC.Base.Just
                             @ GHC.Base.String
                             (XMonad.Util.Lemonbar.lbFontIdx fn x1) } },
                      case ipv1 of wild { (,) a1 s' -> s' }) #) })
                   `cast`
                 (Trans
                      (<XMonad.Core.XState>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <(GHC.Base.Maybe GHC.Base.String, XMonad.Core.XState)>_R))
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <XMonad.Core.XState>_N
                                <GHC.Types.IO>_R
                                <GHC.Base.Maybe GHC.Base.String>_N)))) -}
e4205109b24e34dfd0030121c5f17c17
  lbLineColor ::
    GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U><L,1*U>,
     Unfolding: (\ (c :: GHC.Base.String) (s :: GHC.Base.String) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   XMonad.Util.Lemonbar.lbLineColor2
                   (GHC.Base.++
                      @ GHC.Types.Char
                      c
                      (GHC.Base.++
                         @ GHC.Types.Char
                         XMonad.Util.Lemonbar.lbColor4
                         (GHC.Base.++
                            @ GHC.Types.Char
                            s
                            XMonad.Util.Lemonbar.lbLineColor1)))) -}
1b30cde7009a6317b9435b34c51d1fec
  lbLineColor1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{U-}"#) -}
db27afe4e4ebc91d71d356c3541465c3
  lbLineColor2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{U"#) -}
f5a6659fd82245b952326bf6acf13b0b
  lbLineColorL ::
    GHC.Base.String
    -> XMonad.Util.Loggers.Logger -> XMonad.Util.Loggers.Logger
  {- Arity: 3, Strictness: <L,U><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                XMonad.Util.Lemonbar.lbLineColorL1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N
                 ->_R Trans
                          (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                    <*>_N
                                    <XMonad.Core.XConf>_R
                                    <Control.Monad.Trans.State.Lazy.StateT
                                       XMonad.Core.XState GHC.Types.IO>_R
                                    <GHC.Base.Maybe GHC.Base.String>_N))
                          (Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N)) -}
67aca7436065df3b7608c64fc5f8c14c
  lbLineColorL1 ::
    GHC.Base.String
    -> Control.Monad.Trans.Reader.ReaderT
         XMonad.Core.XConf
         (Control.Monad.Trans.State.Lazy.StateT
            XMonad.Core.XState GHC.Types.IO)
         (GHC.Base.Maybe GHC.Base.String)
    -> XMonad.Core.XConf
    -> Control.Monad.Trans.State.Lazy.StateT
         XMonad.Core.XState GHC.Types.IO (GHC.Base.Maybe GHC.Base.String)
  {- Arity: 3, Strictness: <L,U><L,1*C1(U)><L,U>,
     Unfolding: (\ (c :: GHC.Base.String)
                   (eta1 :: Control.Monad.Trans.Reader.ReaderT
                              XMonad.Core.XConf
                              (Control.Monad.Trans.State.Lazy.StateT
                                 XMonad.Core.XState GHC.Types.IO)
                              (GHC.Base.Maybe GHC.Base.String))
                   (eta2 :: XMonad.Core.XConf) ->
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           XMonad.Core.XState GHC.Types.IO (GHC.Base.Maybe GHC.Base.String)
                   = eta1
                       `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <XMonad.Core.XConf>_R
                          <Control.Monad.Trans.State.Lazy.StateT
                             XMonad.Core.XState GHC.Types.IO>_R
                          <GHC.Base.Maybe GHC.Base.String>_N)
                       eta2
                 } in
                 (\ (s1 :: XMonad.Core.XState)
                    (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <XMonad.Core.XState>_N
                             <GHC.Types.IO>_R
                             <GHC.Base.Maybe GHC.Base.String>_N)
                          s1)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <(GHC.Base.Maybe GHC.Base.String, XMonad.Core.XState)>_R)
                         eta of ds { (#,#) ipv ipv1 ->
                  (# ipv,
                     (case ipv1 of wild { (,) a1 s' ->
                      case a1 of wild1 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Base.String
                        GHC.Base.Just x1
                        -> GHC.Base.Just
                             @ GHC.Base.String
                             (XMonad.Util.Lemonbar.lbLineColor c x1) } },
                      case ipv1 of wild { (,) a1 s' -> s' }) #) })
                   `cast`
                 (Trans
                      (<XMonad.Core.XState>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <(GHC.Base.Maybe GHC.Base.String, XMonad.Core.XState)>_R))
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <XMonad.Core.XState>_N
                                <GHC.Types.IO>_R
                                <GHC.Base.Maybe GHC.Base.String>_N)))) -}
03a46d4809a659944ba0f88b3ada46d9
  lbOverline :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1,
     Unfolding: (XMonad.Hooks.DynamicLog.wrap
                   XMonad.Util.Lemonbar.lbOverline2
                   XMonad.Util.Lemonbar.lbOverline1) -}
c174328ec75ed4f8be46f95529e8e8a8
  lbOverline1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{-o}"#) -}
fe2c222eb00c269e73ea72058efb3019
  lbOverline2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{+o}"#) -}
271dee6d8ac563bb61b813321335aebf
  lbOverlineL ::
    XMonad.Util.Loggers.Logger -> XMonad.Util.Loggers.Logger
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                XMonad.Util.Lemonbar.lbOverlineL1
                  `cast`
                (Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N
                 ->_R Trans
                          (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                    <*>_N
                                    <XMonad.Core.XConf>_R
                                    <Control.Monad.Trans.State.Lazy.StateT
                                       XMonad.Core.XState GHC.Types.IO>_R
                                    <GHC.Base.Maybe GHC.Base.String>_N))
                          (Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N)) -}
a1643d02181c9afb01f5b5071eb07296
  lbOverlineL1 ::
    Control.Monad.Trans.Reader.ReaderT
      XMonad.Core.XConf
      (Control.Monad.Trans.State.Lazy.StateT
         XMonad.Core.XState GHC.Types.IO)
      (GHC.Base.Maybe GHC.Base.String)
    -> XMonad.Core.XConf
    -> Control.Monad.Trans.State.Lazy.StateT
         XMonad.Core.XState GHC.Types.IO (GHC.Base.Maybe GHC.Base.String)
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: (\ (eta1 :: Control.Monad.Trans.Reader.ReaderT
                              XMonad.Core.XConf
                              (Control.Monad.Trans.State.Lazy.StateT
                                 XMonad.Core.XState GHC.Types.IO)
                              (GHC.Base.Maybe GHC.Base.String))
                   (eta2 :: XMonad.Core.XConf) ->
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           XMonad.Core.XState GHC.Types.IO (GHC.Base.Maybe GHC.Base.String)
                   = eta1
                       `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <XMonad.Core.XConf>_R
                          <Control.Monad.Trans.State.Lazy.StateT
                             XMonad.Core.XState GHC.Types.IO>_R
                          <GHC.Base.Maybe GHC.Base.String>_N)
                       eta2
                 } in
                 (\ (s1 :: XMonad.Core.XState)
                    (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <XMonad.Core.XState>_N
                             <GHC.Types.IO>_R
                             <GHC.Base.Maybe GHC.Base.String>_N)
                          s1)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <(GHC.Base.Maybe GHC.Base.String, XMonad.Core.XState)>_R)
                         eta of ds { (#,#) ipv ipv1 ->
                  (# ipv,
                     (case ipv1 of wild { (,) a1 s' ->
                      case a1 of wild1 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Base.String
                        GHC.Base.Just x1
                        -> GHC.Base.Just
                             @ GHC.Base.String
                             (XMonad.Hooks.DynamicLog.wrap
                                XMonad.Util.Lemonbar.lbOverline2
                                XMonad.Util.Lemonbar.lbOverline1
                                x1) } },
                      case ipv1 of wild { (,) a1 s' -> s' }) #) })
                   `cast`
                 (Trans
                      (<XMonad.Core.XState>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <(GHC.Base.Maybe GHC.Base.String, XMonad.Core.XState)>_R))
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <XMonad.Core.XState>_N
                                <GHC.Types.IO>_R
                                <GHC.Base.Maybe GHC.Base.String>_N)))) -}
643893ab53dbf9248ad22c0f35426fde
  lbReverse :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1,
     Unfolding: (XMonad.Hooks.DynamicLog.wrap
                   XMonad.Util.Lemonbar.lbReverse1
                   XMonad.Util.Lemonbar.lbReverse1) -}
f8513d8df6cc57e39312bf02770c98fe
  lbReverse1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{R}"#) -}
bb10d1350666942318d7fe3a904acb4d
  lbReverseL ::
    XMonad.Util.Loggers.Logger -> XMonad.Util.Loggers.Logger
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                XMonad.Util.Lemonbar.lbReverseL1
                  `cast`
                (Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N
                 ->_R Trans
                          (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                    <*>_N
                                    <XMonad.Core.XConf>_R
                                    <Control.Monad.Trans.State.Lazy.StateT
                                       XMonad.Core.XState GHC.Types.IO>_R
                                    <GHC.Base.Maybe GHC.Base.String>_N))
                          (Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N)) -}
c73728e98642bf3f7ccd3e294edd9684
  lbReverseL1 ::
    Control.Monad.Trans.Reader.ReaderT
      XMonad.Core.XConf
      (Control.Monad.Trans.State.Lazy.StateT
         XMonad.Core.XState GHC.Types.IO)
      (GHC.Base.Maybe GHC.Base.String)
    -> XMonad.Core.XConf
    -> Control.Monad.Trans.State.Lazy.StateT
         XMonad.Core.XState GHC.Types.IO (GHC.Base.Maybe GHC.Base.String)
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: (\ (eta1 :: Control.Monad.Trans.Reader.ReaderT
                              XMonad.Core.XConf
                              (Control.Monad.Trans.State.Lazy.StateT
                                 XMonad.Core.XState GHC.Types.IO)
                              (GHC.Base.Maybe GHC.Base.String))
                   (eta2 :: XMonad.Core.XConf) ->
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           XMonad.Core.XState GHC.Types.IO (GHC.Base.Maybe GHC.Base.String)
                   = eta1
                       `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <XMonad.Core.XConf>_R
                          <Control.Monad.Trans.State.Lazy.StateT
                             XMonad.Core.XState GHC.Types.IO>_R
                          <GHC.Base.Maybe GHC.Base.String>_N)
                       eta2
                 } in
                 (\ (s1 :: XMonad.Core.XState)
                    (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <XMonad.Core.XState>_N
                             <GHC.Types.IO>_R
                             <GHC.Base.Maybe GHC.Base.String>_N)
                          s1)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <(GHC.Base.Maybe GHC.Base.String, XMonad.Core.XState)>_R)
                         eta of ds { (#,#) ipv ipv1 ->
                  (# ipv,
                     (case ipv1 of wild { (,) a1 s' ->
                      case a1 of wild1 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Base.String
                        GHC.Base.Just x1
                        -> GHC.Base.Just
                             @ GHC.Base.String
                             (XMonad.Hooks.DynamicLog.wrap
                                XMonad.Util.Lemonbar.lbReverse1
                                XMonad.Util.Lemonbar.lbReverse1
                                x1) } },
                      case ipv1 of wild { (,) a1 s' -> s' }) #) })
                   `cast`
                 (Trans
                      (<XMonad.Core.XState>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <(GHC.Base.Maybe GHC.Base.String, XMonad.Core.XState)>_R))
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <XMonad.Core.XState>_N
                                <GHC.Types.IO>_R
                                <GHC.Base.Maybe GHC.Base.String>_N)))) -}
4f0be7bb3f2e711abdd8a44d92e9a329
  lbUnderline :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1,
     Unfolding: (XMonad.Hooks.DynamicLog.wrap
                   XMonad.Util.Lemonbar.lbUnderline2
                   XMonad.Util.Lemonbar.lbUnderline1) -}
4f391ecf0674f6960fc4c1fdde1c48d3
  lbUnderline1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{-u}"#) -}
e19e6dc68dc9571be0e3de831f4b457b
  lbUnderline2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%{+u}"#) -}
2564f30dd2b8f51d4d3ddc4a59735b36
  lbUnderlineL ::
    XMonad.Util.Loggers.Logger -> XMonad.Util.Loggers.Logger
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                XMonad.Util.Lemonbar.lbUnderlineL1
                  `cast`
                (Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N
                 ->_R Trans
                          (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                    <*>_N
                                    <XMonad.Core.XConf>_R
                                    <Control.Monad.Trans.State.Lazy.StateT
                                       XMonad.Core.XState GHC.Types.IO>_R
                                    <GHC.Base.Maybe GHC.Base.String>_N))
                          (Sym (XMonad.Core.N:X[0]) <GHC.Base.Maybe GHC.Base.String>_N)) -}
ce6ff74dc91435258bf1baa0724619fd
  lbUnderlineL1 ::
    Control.Monad.Trans.Reader.ReaderT
      XMonad.Core.XConf
      (Control.Monad.Trans.State.Lazy.StateT
         XMonad.Core.XState GHC.Types.IO)
      (GHC.Base.Maybe GHC.Base.String)
    -> XMonad.Core.XConf
    -> Control.Monad.Trans.State.Lazy.StateT
         XMonad.Core.XState GHC.Types.IO (GHC.Base.Maybe GHC.Base.String)
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: (\ (eta1 :: Control.Monad.Trans.Reader.ReaderT
                              XMonad.Core.XConf
                              (Control.Monad.Trans.State.Lazy.StateT
                                 XMonad.Core.XState GHC.Types.IO)
                              (GHC.Base.Maybe GHC.Base.String))
                   (eta2 :: XMonad.Core.XConf) ->
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           XMonad.Core.XState GHC.Types.IO (GHC.Base.Maybe GHC.Base.String)
                   = eta1
                       `cast`
                     (Control.Monad.Trans.Reader.N:ReaderT[0]
                          <*>_N
                          <XMonad.Core.XConf>_R
                          <Control.Monad.Trans.State.Lazy.StateT
                             XMonad.Core.XState GHC.Types.IO>_R
                          <GHC.Base.Maybe GHC.Base.String>_N)
                       eta2
                 } in
                 (\ (s1 :: XMonad.Core.XState)
                    (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <XMonad.Core.XState>_N
                             <GHC.Types.IO>_R
                             <GHC.Base.Maybe GHC.Base.String>_N)
                          s1)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <(GHC.Base.Maybe GHC.Base.String, XMonad.Core.XState)>_R)
                         eta of ds { (#,#) ipv ipv1 ->
                  (# ipv,
                     (case ipv1 of wild { (,) a1 s' ->
                      case a1 of wild1 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Base.String
                        GHC.Base.Just x1
                        -> GHC.Base.Just
                             @ GHC.Base.String
                             (XMonad.Hooks.DynamicLog.wrap
                                XMonad.Util.Lemonbar.lbUnderline2
                                XMonad.Util.Lemonbar.lbUnderline1
                                x1) } },
                      case ipv1 of wild { (,) a1 s' -> s' }) #) })
                   `cast`
                 (Trans
                      (<XMonad.Core.XState>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <(GHC.Base.Maybe GHC.Base.String, XMonad.Core.XState)>_R))
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <XMonad.Core.XState>_N
                                <GHC.Types.IO>_R
                                <GHC.Base.Maybe GHC.Base.String>_N)))) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

